["```py\nthought\n{\n    id integer\n    username string\n    text string\n    timestamp string($date-time)\n}\n```", "```py\nclass ThoughtModel(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(50))\n    text = db.Column(db.String(250))\n    timestamp = db.Column(db.DateTime, server_default=func.now())\n```", "```py\n# Retrieve a single thought by its primary key\nthought = ThoughtModel.query.get(thought_id)\n# Retrieve all thoughts filtered by a username\nthoughts = ThoughtModel.query.filter_by(username=username)\n.order_by('id').all()\n```", "```py\n# Create a new thought\nnew_thought = ThoughtModel(username=username, text=text, timestamp=datetime.utcnow())\ndb.session.add(new_thought)\ndb.session.commit()\n\n# Retrieve and delete a thought\nthought = ThoughtModel.query.get(thought_id)\ndb.session.delete(thought)\ndb.session.commit()\n```", "```py\napi_namespace = Namespace('api', description='API operations')\n\n@api_namespace.route('/thoughts/<int:thought_id>/')\nclass ThoughtsRetrieve(Resource):\n\n    @api_namespace.doc('retrieve_thought')\n    @api_namespace.marshal_with(thought_model)\n    def get(self, thought_id):\n        '''\n        Retrieve a thought\n        '''\n        thought = ThoughtModel.query.get(thought_id)\n        if not thought:\n            # The thought is not present\n            return '', http.client.NOT_FOUND\n\n        return thought\n```", "```py\napi_namespace = Namespace('api', description='API operations')\n\n@api_namespace.route('/thoughts/<int:thought_id>/')\nclass ThoughtsRetrieve(Resource):\n    ...\n```", "```py\nclass ThoughtsRetrieve(Resource):\n\n    def get(self, thought_id):\n        ...\n```", "```py\ndef get(self, thought_id):\n    thought = ThoughtModel.query.get(thought_id)\n    if not thought:\n        # The thought is not present\n        return '', http.client.NOT_FOUND\n\n    return thought\n```", "```py\n@api_namespace.marshal_with(thought_model)\ndef get(self, thought_id):\n    ...\n    return thought\n```", "```py\nclass ThoughtsRetrieve(Resource):\n\n    @api_namespace.doc('retrieve_thought')\n    def get(self, thought_id):\n        '''\n        Retrieve a thought\n        '''\n        ...\n```", "```py\nhttp://test.com/some/path?param1=X&param2=Y\n```", "```py\nauthentication_parser = api_namespace.parser()\nauthentication_parser.add_argument('Authorization', \nlocation='headers', type=str, help='Bearer Access \nToken')\n\nthought_parser = authentication_parser.copy()\nthought_parser.add_argument('text', type=str, required=True, help='Text of the thought')\n\n@api_namespace.route('/me/thoughts/')\nclass MeThoughtListCreate(Resource):\n\n    @api_namespace.expect(thought_parser)\n    def post(self):\n        args = thought_parser.parse_args()\n        username = authentication_header_parser(args['Authorization'])\n        text=args['text']\n        ...\n\n```", "```py\nauthentication_parser = api_namespace.parser()\nauthentication_parser.add_argument('Authorization', \nlocation='headers', type=str, help='Bearer Access Token')\n\nthought_parser = authentication_parser.copy()\nthought_parser.add_argument('text', type=str, required=True, help='Text of the thought')\n```", "```py\n@api_namespace.route('/me/thoughts/')\nclass MeThoughtListCreate(Resource):\n\n    @api_namespace.expect(thought_parser)\n    def post(self):\n        args = thought_parser.parse_args()\n        ...\n```", "```py\ndef authentication_header_parser(value):\n    username = validate_token_header(value, config.PUBLIC_KEY)\n    if username is None:\n        abort(401)\n    return username\n\nclass MeThoughtListCreate(Resource):\n\n    @api_namespace.expect(thought_parser)\n    def post(self):\n       args = thought_parser.parse_args()\n       username = authentication_header_parser(args['Authentication'])\n       ...\n```", "```py\nfrom flask_restplus import fields\n\nmodel = {\n    'id': fields.Integer(),\n    'username': fields.String(),\n    'text': fields.String(),\n    'timestamp': fields.DateTime(),\n}\nthought_model = api_namespace.model('Thought', model)\n```", "```py\n@api_namespace.route('/me/thoughts/')\nclass MeThoughtListCreate(Resource):\n\n    @api_namespace.marshal_with(thought_model)\n    def post(self):\n        ...\n        new_thought = ThoughtModel(...)\n        return new_thought\n```", "```py\nmodel = {\n    'timestamp': fields.DateTime(default=datetime.utcnow),\n}\n```", "```py\nmodel = {\n    'thought_text': fields.String(attribute='text'),\n    'thought_username': fields.String(attribute=lambda x: x.username),\n }\n```", "```py\nextra = {\n   'info': fields.String(),\n}\nextra_info = api_namespace.model('ExtraInfo', extra)\n\nmodel = {\n    'extra': fields.Nested(extra),\n    'extra_list': fields.List(fields.Nested(extra)),\n }\n\n```", "```py\n@api_namespace.route('/me/thoughts/')\nclass MeThoughtListCreate(Resource):\n\n    @api_namespace.marshal_with(thought_model, as_list=True)\n    def get(self):\n        ...\n        thoughts = (\n            ThoughtModel.query.filter(\n                ThoughtModel.username == username\n            )\n            .order_by('id').all()\n        )\n        return thoughts\n\n```", "```py\n@api_namespace.route('/me/thoughts/')\nclass MeThoughtListCreate(Resource):\n\n    @api_namespace.marshal_with(thought_model, \n         code=http.client.CREATED)\n    def post(self):\n        ...\n        result = api_namespace.marshal(new_thought, thought_model)\n        return result, http.client.CREATED\n```", "```py\n@api_namespace.route('/thoughts/')\nclass ThoughtList(Resource):\n\n    @api_namespace.doc('list_thoughts')\n    @api_namespace.marshal_with(thought_model, as_list=True)\n    @api_namespace.expect(search_parser)\n    def get(self):\n        '''\n        Retrieves all the thoughts\n        '''\n        args = search_parser.parse_args()\n        search_param = args['search']\n        # Action\n        query = ThoughtModel.query\n        if search_param:\n            query =(query.filter(\n                ThoughtModel.text.contains(search_param)))\n\n        query = query.order_by('id')\n        thoughts = query.all()\n        # Return the result\n        return thoughts\n```", "```py\ndef encode_token(payload, private_key):\n    return jwt.encode(payload, private_key, algorithm='RS256')\n\ndef generate_token_header(username, private_key):\n    '''\n    Generate a token header base on the username. \n    Sign using the private key.\n    '''\n    payload = {\n        'username': username,\n        'iat': datetime.utcnow(),\n        'exp': datetime.utcnow() + timedelta(days=2),\n    }\n    token = encode_token(payload, private_key)\n    token = token.decode('utf8')\n    return f'Bearer {token}'\n```", "```py\ndef decode_token(token, public_key):\n    return jwt.decode(token, public_key, algoritms='RS256')\n```", "```py\ndef validate_token_header(header, public_key):\n    if not header:\n        logger.info('No header')\n        return None\n\n    # Retrieve the Bearer token\n    parse_result = parse('Bearer {}', header)\n    if not parse_result:\n        logger.info(f'Wrong format for header \"{header}\"')\n        return None\n    token = parse_result[0]\n```", "```py\n    try:\n        decoded_token = decode_token(token.encode('utf8'), public_key)\n    except jwt.exceptions.DecodeError:\n        logger.warning(f'Error decoding header \"{header}\". '\n        'This may be key missmatch or wrong key')\n        return None\n    except jwt.exceptions.ExpiredSignatureError:\n        logger.info(f'Authentication header has expired')\n        return None\n```", "```py\n    # Check expiry is in the token\n    if 'exp' not in decoded_token:\n        logger.warning('Token does not have expiry (exp)')\n        return None\n\n    # Check username is in the token\n    if 'username' not in decoded_token:\n        logger.warning('Token does not have username')\n        return None\n\n    logger.info('Header successfully validated')\n    return decoded_token['username']\n```", "```py\n$ openssl genrsa -out key.pem 2048\nGenerating RSA private key, 2048 bit long modulus\n.....................+++\n.............................+++\n```", "```py\n$ openssl rsa -in key.pem -outform PEM -pubout -out key.pub\n```", "```py\n>> with open('private.pem') as fp:\n>> ..  private_key = fp.read()\n\n>> generate_token_header('peter', private_key)\n'Bearer <token>'\n```", "```py\n$ pytest\n============== test session starts ==============\n....\n==== 17 passed, 177 warnings in 1.50 seconds =====\n\n```", "```py\n@pytest.fixture\ndef thought_fixture(client):\n\n    thought_ids = []\n    for _ in range(3):\n        thought = {\n            'text': fake.text(240),\n        }\n        header = token_validation.generate_token_header(fake.name(),\n                                                        PRIVATE_KEY)\n        headers = {\n            'Authorization': header,\n        }\n        response = client.post('/api/me/thoughts/', data=thought,\n                               headers=headers)\n        assert http.client.CREATED == response.status_code\n        result = response.json\n        thought_ids.append(result['id'])\n```", "```py\nyield thought_ids\n```", "```py\n# Clean up all thoughts\nresponse = client.get('/api/thoughts/')\nthoughts = response.json\nfor thought in thoughts:\n    thought_id = thought['id']\n    url = f'/admin/thoughts/{thought_id}/'\n    response = client.delete(url)\n    assert http.client.NO_CONTENT == response.status_code\n```", "```py\n@freeze_time('2018-05-17 13:47:34')\ndef test_invalid_token_header_expired():\n    expiry = delorean.parse('2018-05-17 13:47:33').datetime\n    payload = {\n        'username': 'tonystark',\n        'exp': expiry,\n    }\n    token = token_validation.encode_token(payload, PRIVATE_KEY)\n    token = token.decode('utf8')\n    header = f'Bearer {token}'\n    result = token_validation.validate_token_header(header, PUBLIC_KEY)\n    assert None is result\n```"]