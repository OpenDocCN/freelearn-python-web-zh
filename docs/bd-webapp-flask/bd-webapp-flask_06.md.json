["```py\npip install marshmallow\n\n```", "```py\n# coding:utf-8\n\nfrom flask import Flask, jsonify\nfrom flask.ext.sqlalchemy import SQLAlchemy\n\nfrom marshmallow import Schema\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'secret'\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/articles.sqlite'\n\ndb = SQLAlchemy(app)\n\nclass Article(db.Model):\n    __tablename__ = 'articles'\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(100), nullable=False)\n    content = db.Column(db.Text(), nullable=False)\n\n    def __unicode__(self):\n        return self.content\n\n# we use marshmallow Schema to serialize our articles\nclass ArticleSchema(Schema):\n    \"\"\"\n    Article dict serializer\n    \"\"\"\n    class Meta:\n        # which fields should be serialized?\n        fields = ('id', 'title', 'content')\n\narticle_schema = ArticleSchema()\n# many -> allow for object list dump\narticles_schema = ArticleSchema(many=True)\n\n@app.route(\"/articles/\", methods=[\"GET\"])\n@app.route(\"/articles/<article_id>\", methods=[\"GET\"])\ndef articles(article_id=None):\n    if article_id:\n        article = Article.query.get(article_id)\n\n        if article is None:\n            return jsonify({\"msgs\": [\"the article you're looking for could not be found\"]}), 404\n\n        result = article_schema.dump(article)\n        return jsonify({'article': result})\n    else:\n        # never return the whole set! As it would be very slow\n        queryset = Article.query.limit(10)\n        result = articles_schema.dump(queryset)\n\n        # jsonify serializes our dict into a proper flask response\n        return jsonify({\"articles\": result.data})\n\ndb.create_all()\n\n# let's populate our database with some data; empty examples are not that cool\nif Article.query.count() == 0:\n    article_a = Article(title='some title', content='some content')\n    article_b = Article(title='other title', content='other content')\n\n    db.session.add(article_a)\n    db.session.add(article_b)\n    db.session.commit()\n\nif __name__ == '__main__':\n    # we define the debug environment only if running through command line\n    app.config['SQLALCHEMY_ECHO'] = True\n    app.debug = True\n    app.run()\n```", "```py\nfrom flask import request\n\u2026\n\n@app.route(\"/articles/\", methods=[\"GET\"])\n@app.route(\"/articles/<article_id>\", methods=[\"GET\"])\ndef articles(article_id=None):\n    if article_id:\n        article = Article.query.get(article_id)\n\n        if request.is_xhr:\n            if article is None:\n                return jsonify({\"msgs\": [\"the article you're looking for could not be found\"]}), 404\n\n            result = article_schema.dump(article)\n            return jsonify({'article': result})\n        else:\n            if article is None:\n                abort(404)\n\n            return render_template('article.html', article=article)\n    else:\n        queryset = Article.query.limit(10)\n\n        if request.is_xhr:\n            # never return the whole set! As it would be very slow\n            result = articles_schema.dump(queryset)\n\n            # jsonify serializes our dict into a proper flask response\n            return jsonify({\"articles\": result.data})\n        else:\n            return render_template('articles.html', articles=queryset)\n```", "```py\nfrom marshmallow import Schema, fields\nclass ArticleSchema(Schema):\n    \"\"\"\n      Article dict serializer\n      \"\"\"\n      url = fields.Method(\"article_url\")\n      def article_url(self, article):\n          return article.url()\n\n      class Meta:\n          # which fields should be serialized?\n          fields = ('id', 'title', 'content', 'url')\n\n@app.route(\"/articles/\", methods=[\"GET\"])\n@app.route(\"/articles/<article_id>\", methods=[\"GET\"])\ndef articles(article_id=None):\n    if article_id:\n        if request.is_xhr:\n            article = Article.query.get(article_id)\n            if article is None:\n                return jsonify({\"msgs\": [\"the article you're looking for could not be found\"]}), 404\n\n            result = article_schema.dump(article)\n            return jsonify({'article': result})\n        else:\n            return render_template('article.html')\n    else:\n        if request.is_xhr:\n            queryset = Article.query.limit(10)\n            # never return the whole set! As it would be very slow\n            result = articles_schema.dump(queryset)\n\n            # jsonify serializes our dict into a proper flask response\n            return jsonify({\"articles\": result.data})\n        else:\n            return render_template('articles.html')\n```", "```py\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Articles</title>\n</head>\n<body>\n<ul id=\"articles\">\n</ul>\n\n<script type=\"text/javascript\" src=\"img/jquery-2.1.3.min.js\"></script>\n<script type=\"text/javascript\">\n  // only execute after loading the whole HTML\n  $(document).ready(function(){\n    $.ajax({\n      url:\"{{ url_for('.articles') }}\",\n      success: function(data, textStatus, xhr){\n        $(data['articles']).each(function(i, el){\n          var link = \"<a href='\"+ el['url'] +\"'>\" + el['title'] + \"</a>\";\n          $(\"#articles\").append(\"<li>\" + link + \"</li>\");\n        });}});}); // don't do this in live code\n</script>\n</body>\n</html>\n```", "```py\n@app.route(\"/articles/\", methods=[\"GET\", \"POST\"])\n@app.route(\"/articles/<int:article_id>\", methods=[\"GET\", \"PUT\", \"DELETE\"])\ndef articles(article_id=None):\n    if request.method == \"GET\":\n        if article_id:\n            article = Article.query.get(article_id)\n\n            if request.is_xhr:\n                if article is None:\n                    return jsonify({\"msgs\": [\"the article you're looking for could not be found\"]}), 404\n\n                result = article_schema.dump(article)\n                return jsonify({': result.data})\n\n            return render_template('article.html', article=article, form=ArticleForm(obj=article))\n        else:\n            if request.is_xhr:\n                # never return the whole set! As it would be very slow\n                queryset = Article.query.limit(10)\n                result = articles_schema.dump(queryset)\n\n                # jsonify serializes our dict into a proper flask response\n                return jsonify({\"articles\": result.data})\n    elif request.method == \"POST\" and request.is_xhr:\n        form = ArticleForm(request.form)\n\n        if form.validate():\n            article = Article()\n            form.populate_obj(article)\n            db.session.add(article)\n            db.session.commit()\n            return jsonify({\"msgs\": [\"article created\"]})\n        else:\n            return jsonify({\"msgs\": [\"the sent data is not valid\"]}), 400\n\n    elif request.method == \"PUT\" and request.is_xhr:\n        article = Article.query.get(article_id)\n\n        if article is None:\n            return jsonify({\"msgs\": [\"the article you're looking for could not be found\"]}), 404\n\n        form = ArticleForm(request.form, obj=article)\n\n        if form.validate():\n            form.populate_obj(article)\n            db.session.add(article)\n            db.session.commit()\n            return jsonify({\"msgs\": [\"article updated\"]})\n        else:\n            return jsonify({\"msgs\": [\"the sent data was not valid\"]}), 400\n    elif request.method == \"DELETE\" and request.is_xhr:\n        article = Article.query.get(article_id)\n\n        if article is None:\n            return jsonify({\"msgs\": [\"the article you're looking for could not be found\"]}), 404\n\n        db.session.delete(article)\n        db.session.commit()\n        return jsonify({\"msgs\": [\"article removed\"]})\n\n    return render_template('articles.html', form=ArticleForm())\n```", "```py\npip install Flask-Restless\n\n```", "```py\n# coding:utf-8\n\nfrom flask import Flask, url_for\nfrom flask.ext.restless import APIManager\nfrom flask.ext.sqlalchemy import SQLAlchemy\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'secret'\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/employees.sqlite'\n\ndb = SQLAlchemy(app)\n\nclass Article(db.Model):\n    __tablename__ = 'articles'\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(100), nullable=False)\n    content = db.Column(db.String(255), nullable=False)\n\n    def __unicode__(self):\n        return self.content\n\n    def url(self):\n        return url_for('.articles', article_id=self.id)\n\n# create the Flask-Restless API manager\nmanager = APIManager(app, flask_sqlalchemy_db=db)\n\n# create our Article API at /api/articles\nmanager.create_api(Article, collection_name='articles', methods=['GET', 'POST', 'PUT', 'DELETE'])\n\ndb.create_all()\n\nif __name__ == '__main__':\n    # we define the debug environment only if running through command line\n    app.config['SQLALCHEMY_ECHO'] = True\n    app.debug = True\n    app.run()\n```", "```py\ncurl http://127.0.0.1:5000/api/articles\n\n```", "```py\nmanager.create_api(Model, methods=METHODS,\n                   serializer=my_serializer,\n                   deserializer=my_deserializer)\ndef my_serializer(instance):\n    return some_schema.dump(instance).data\n\ndef my_deserializer(data):\n    return some_schema.load(data).data\n```", "```py\n# both the statements below are equivalents\nmanager.create_api(Article, methods=['GET'], include_columns=['id', 'title'])\nmanager.create_api(Article, methods=['GET'], exclude_columns=['content'])\n```"]