["```py\nvirtualenv .env -p python3.6\nsource .env/bin/activate\n```", "```py\nFlask==0.12.2\nFlask-JWT==0.3.2\nFlask-SQLAlchemy==2.3.2\nFlask-Migrate==2.1.1\nflask-restful==0.3.6\nzappa==0.45.1\n\n```", "```py\n$ pip install -r requirements.txt\n```", "```py\n__init__.py, where we configured the Flask application object with extensions and the\u00a0config object.\n```", "```py\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\nfrom flask_jwt import JWT, jwt_required, current_identity\n\nfrom app.config import config\n\ndb = SQLAlchemy()\nmigrate = Migrate()\n\ndef create_app(environment):\n    app = Flask(__name__)\n    app.config.from_object(config[environment])\n\n    db.init_app(app)\n    migrate.init_app(app, db=db)\n\n    from .auth.models import User\n\n    def authenticate(email, password):\n        data = request.json\n        user = User.query.filter_by(email=data['email']).first()\n        if user is not None and user.verify_password(data['password']):\n            return user\n\n    def identity(payload):\n        user_id = payload['identity']\n        return User.query.filter_by(id=user_id).first()\n\n    jwt = JWT(app, authenticate, identity)\n\n    from .auth import auth as auth_blueprint\n    app.register_blueprint(auth_blueprint, url_prefix='/auth')\n\n    from .todo import todo as todo_blueprint\n    app.register_blueprint(todo_blueprint)\n\n    return app\n```", "```py\nimport os\nfrom shutil import copyfile\n\nBASE_DIR = os.path.dirname(os.path.dirname(__file__))\n\ndef get_sqlite_uri(db_name):\n    src = os.path.join(BASE_DIR, db_name)\n    dst = \"/tmp/%s\" % db_name\n    copyfile(src, dst)\n    return 'sqlite:///%s' % dst\n\nclass Config(object):\n    SECRET_KEY = os.environ.get('SECRET_KEY') or os.urandom(24)\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n    SQLALCHEMY_RECORD_QUERIES = True\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n\n    @staticmethod\n    def init_app(app):\n        pass\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n    BUNDLE_ERRORS = True\n    SQLALCHEMY_DATABASE_URI = get_sqlite_uri('todo-dev.db')\n\nclass ProductionConfig(Config):\n    SQLALCHEMY_DATABASE_URI = get_sqlite_uri('todo-prod.db')\n\nconfig = {\n    'dev': DevelopmentConfig,\n    'prod': ProductionConfig,\n}\n```", "```py\nBaseModel, which was inspired by Django's standard pattern to perform save, update, and delete operations. We can add more generic features if required.\n```", "```py\n\nfrom app import db\n\nclass BaseModel:\n    \"\"\"\n    Base Model with common operations.\n    \"\"\"\n\n    def delete(self):\n        db.session.delete(self)\n        db.session.commit()\n\n    def save(self):\n        db.session.add(self)\n        db.session.commit()\n        return self\n```", "```py\nUser model.\n```", "```py\nimport re\nfrom datetime import datetime\n\nfrom app.config.models import BaseModel\nfrom sqlalchemy.orm import synonym\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom app import db\n\nclass User(BaseModel, db.Model):\n    __tablename__ = 'user'\n    id = db.Column(db.Integer, primary_key=True)\n    _email = db.Column('email', db.String(64), unique=True)\n    password_hash = db.Column(db.String(128))\n\n    def __init__(self, **kwargs):\n        super(User, self).__init__(**kwargs)\n\n    def __repr__(self):\n        return '<User {0}>'.format(self.email)\n\n    @property\n    def email(self):\n        return self._email\n\n    @email.setter\n    def email(self, email):\n        if not len(email) <= 64 or not bool(re.match(r'^\\S+@\\S+\\.\\S+$', email)):\n            raise ValueError('{} is not a valid email address'.format(email))\n        self._email = email\n\n    email = synonym('_email', descriptor=email)\n\n    @property\n    def password(self):\n        raise AttributeError('password is not a readable attribute')\n\n    @password.setter\n    def password(self, password):\n        if not bool(password):\n            raise ValueError('no password given')\n\n        hashed_password = generate_password_hash(password)\n        if not len(hashed_password) <= 128:\n            raise ValueError('not a valid password, hash is too long')\n        self.password_hash = hashed_password\n\n    def verify_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\n    def to_dict(self):\n        return {\n            'email': self.email\n        }\n```", "```py\nfrom flask import request, jsonify\nfrom flask_restful import Resource, reqparse, abort\nfrom flask_jwt import current_app\nfrom app.auth.models import User\n\ndef generate_token(user):\n    \"\"\" Currently this is workaround\n    since the latest version that already has this function\n    is not published on PyPI yet and we don't want\n    to install the package directly from GitHub.\n    See: https://github.com/mattupstate/flask-jwt/blob/9f4f3bc8dce9da5dd8a567dfada0854e0cf656ae/flask_jwt/__init__.py#L145\n    \"\"\"\n    jwt = current_app.extensions['jwt']\n    token = jwt.jwt_encode_callback(user)\n    return token\n\nclass SignUpResource(Resource):\n    parser = reqparse.RequestParser(bundle_errors=True)\n    parser.add_argument('email', type=str, required=True)\n    parser.add_argument('password', type=str, required=True)\n\n    def post(self):\n        args = self.parser.parse_args()\n        if not User.query.filter_by(email=args['email']).scalar():\n            User(\n                email = args['email'],\n                password = args['password']\n            ).save()\n            return {'message': 'Sign up successfully'}\n        abort(400, message='Email already exists.')\n\nclass LoginResource(Resource):\n    parser = reqparse.RequestParser(bundle_errors=True)\n    parser.add_argument('email', type=str, required=True)\n    parser.add_argument('password', type=str, required=True)\n\n    def post(self):\n        args = self.parser.parse_args()\n        user = User.query.filter_by(email=args['email']).first()\n        if user is not None and user.verify_password(args['password']):\n            token = generate_token(user)\n            return jsonify({'token': token.decode(\"utf-8\")})\n        abort(400, message='Invalid credentials')\n```", "```py\nauth/__init__.py file.\n```", "```py\nfrom flask import Blueprint\nfrom flask_restful import Api\nfrom .resources import SignUpResource, LoginResource\n\nauth = Blueprint('auth', __name__)\nauth_api = Api(auth, catch_all_404s=True)\n\nauth_api.add_resource(SignUpResource, '/signup', endpoint='signup')\nauth_api.add_resource(LoginResource, '/login', endpoint='login')\n```", "```py\nfrom datetime import datetime\nfrom app import db\nfrom app.config.models import BaseModel\n\nclass Todo(db.Model, BaseModel):\n    __tablename__ = 'todo'\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(128))\n    is_completed = db.Column(db.Boolean, default=False)\n    created_by = db.Column(db.String(64), db.ForeignKey('user.email'))\n    user = db.relationship('User', backref=db.backref('todos', lazy=True))\n\n    def __init__(self, title, created_by=None, created_at=None):\n        self.title = title\n        self.created_by = created_by\n\n    def __repr__(self):\n        return '<{0} Todo: {1} by {2}>'.format(\n            self.status, self.title, self.created_by or 'None')\n\n    @property\n    def status(self):\n        return 'completed' if self.is_completed else 'open'\n\n    def completed(self):\n        self.is_completed = True\n        self.save()\n\n    def reopen(self):\n        self.is_completed = False\n        self.save()\n\n    def to_dict(self):\n        return {\n            'id': self.id,\n            'title': self.title,\n            'created_by': self.created_by,\n            'status': self.status,\n        }\nresources.py, which contains the todo's REST API.\n```", "```py\nfrom flask import request\nfrom flask_restful import Resource, reqparse\nfrom flask_jwt import current_identity, jwt_required\n\nfrom .models import Todo\n\nclass TodoResource(Resource):\n\n    decorators = [jwt_required()]\n\n    def post(self):\n        parser = reqparse.RequestParser(bundle_errors=True)\n        parser.add_argument('title', type=str, required=True)\n\n        args = parser.parse_args(strict=True)\n        todo = Todo(args['title'], created_by=current_identity.email).save()\n        return todo.to_dict(), 201\n\n    def get(self, todo_id=None):\n        if todo_id:\n            todos = Todo.query.filter_by(id=todo_id, created_by=current_identity.email)\n        else:\n            todos = Todo.query.filter_by(created_by=current_identity.email)\n        return [todo.to_dict() for todo in todos]\n\n    def patch(self, todo_id=None):\n        parser = reqparse.RequestParser(bundle_errors=True)\n        parser.add_argument(\n            'status',\n            choices=('open', 'completed'),\n            help='Bad choice: {error_msg}. Valid choices are \\'open\\' or \\'completed\\'.',\n            required=True)\n\n        if not todo_id:\n            return {'error': 'method not allowed'}, 405\n        args = parser.parse_args(strict=True)\n        todo = Todo.query.filter_by(id=todo_id, created_by=current_identity.email).scalar()\n        if args['status'] == \"open\":\n            todo.reopen()\n        elif args['status'] == 'completed':\n            todo.completed()\n        else:\n            return {'error':'Invalid data!'}, 400\n        return todo.to_dict(), 202\n\n    def delete(self, todo_id=None):\n        if not todo_id:\n            return {'error': 'method not allowed'}, 405\n        Todo.query.filter_by(id=int(todo_id), created_by=current_identity.email).delete()\n        return {}, 204\n```", "```py\nzappa_settings.json file.\n```", "```py\n{\n    \"dev\": {\n        \"app_function\": \"run.app\",\n        \"aws_region\": \"ap-south-1\",\n        \"profile_name\": \"default\",\n        \"project_name\": \"chapter-4\",\n        \"runtime\": \"python3.6\",\n        \"s3_bucket\": \"zappa-5xvirta98\"\n    }\n}\n```", "```py\nparser = reqparse.RequestParser(bundle_errors=True)\n        parser.add_argument(\n            'status',\n            choices=('open', 'completed'),\n            help='Bad choice: {error_msg}. Valid choices are \\'open\\' or \\'completed\\'.',\n            required=True)\n```"]