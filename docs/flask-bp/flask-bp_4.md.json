["```py\n$ mkdir -p ~/src/socializer && cd ~/src/socializer\n$ mkvirtualenv socializer\n$ pip install flask flask-sqlalchemy flask-bcrypt flask-login flask-wtf blinker pytest-flask\n\n```", "```py\n\u251c\u2500\u2500 application\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 users\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u2514\u2500\u2500 views.py\n\u2514\u2500\u2500 run.py\n\u2514\u2500\u2500 database.py\n\n```", "```py\nfrom flask import Flask\n\ndef create_app(config=None):\n app = Flask(__name__)\n\n if config is not None:\n app.config.from_object(config)\n\n return app\n\n```", "```py\nfrom flask import current_app as app\n\n```", "```py\nfrom application import create_app\n\napp = create_app()\napp.run(debug=True)\n\n```", "```py\n$ python run.py\n\n```", "```py\n$ python \u2013m run\n\n```", "```py\nfrom myapp import create_app\nimport unittest\n\nclass AppTestCase(unittest.TestCase):\n\n def setUp(self):\n app = create_app()  # Could also pass custom settings.\n app.config['TESTING'] = True\n self.app = app\n\n # Whatever DB initialization is required\n\n def tearDown(self):\n # If anything needs to be cleaned up after a test.\n Pass\n\n def test_app_configuration(self):\n self.assertTrue(self.app.config['TESTING'])\n # Other relevant assertions\n\nif __name__ == '__main__':\n unittest.main()\n\n```", "```py\nimport pytest\nfrom application import create_app\n\n@pytest.fixture\ndef app():\n app = create_app()\n return app\n\n```", "```py\nimport flask\n\ndef test_app(app):\n assert isinstance(app, flask.Flask)\n\n```", "```py\n$ py.test\n=============== test session starts ================\nplatform darwin -- Python 2.7.8 -- py-1.4.26 -- pytest-2.7.0\nrootdir: /path/to/socializer, inifile:\nplugins: flask\ncollected 1 items\n\ntests/test_application.py .\n\n============= 1 passed in 0.02 seconds =============\n\n```", "```py\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\n\n# Initialize the db extension, but without configuring\n# it with an application instance.\ndb = SQLAlchemy()\n\n# The same for the Bcrypt extension\nflask_bcrypt = Bcrypt()\n\ndef create_app(config=None):\n app = Flask(__name__)\n\n if config is not None:\n app.config.from_object(config)\n\n # Initialize any extensions and bind blueprints to the\n # application instance here.\n db.init_app(app)\n flask_bcrypt.init_app(app)\n\n return app\n\n```", "```py\nimport datetime\nfrom application import db, flask_bcrypt\nfrom sqlalchemy.ext.hybrid import hybrid_property\n\n__all__ = ['followers', 'User']\n\n# We use the explicit SQLAlchemy mappers for declaring the\n# followers table, since it does not require any of the features\n# that the declarative base model brings to the table.\n#\n# The `follower_id` is the entry that represents a user who\n# *follows* a `user_id`.\nfollowers = db.Table(\n 'followers',\n db.Column('follower_id', db.Integer, db.ForeignKey('user.id'),\n primary_key=True),\n db.Column('user_id', db.Integer, db.ForeignKey('user.id'),\n primary_key=True))\n\nclass User(db.Model):\n\n # The primary key for each user record.\n id = db.Column(db.Integer, primary_key=True)\n\n # The unique email for each user record.\n email = db.Column(db.String(255), unique=True)\n\n # The unique username for each record.\n username = db.Column(db.String(40), unique=True)\n\n # The hashed password for the user\n _password = db.Column('password', db.String(60))\n #  The date/time that the user account was created on.\n created_on = db.Column(db.DateTime,\n default=datetime.datetime.utcnow)\n\n followed = db.relationship('User',\n secondary=followers,\n primaryjoin=(id==followers.c.follower_id ),\n secondaryjoin=(id==followers.c.user_id),\n backref=db.backref('followers', lazy='dynamic'),\n lazy='dynamic')\n\n @hybrid_property\n def password(self):\n \"\"\"The bcrypt'ed password of the given user.\"\"\"\n\n return self._password\n\n @password.setter\n def password(self, password):\n \"\"\"Bcrypt the password on assignment.\"\"\"\n\n self._password = flask_bcrypt.generate_password_hash(\n password)\n\n def __repr__(self):\n return '<User %r>' % self.username\n\n def is_authenticated(self):\n \"\"\"All our registered users are authenticated.\"\"\"\n return True\n\n def is_active(self):\n \"\"\"All our users are active.\"\"\"\n return True\n\n def is_anonymous(self):\n \"\"\"We don't have anonymous users; always False\"\"\"\n return False\n def get_id(self):\n \"\"\"Get the user ID.\"\"\"\n return unicode(self.id)\n\n```", "```py\n followed = db.relationship('User',\n secondary=followers,\n primaryjoin=(id==followers.c.follower_id ),\n secondaryjoin=(id==followers.c.user_id),\n backref=db.backref('followers', lazy='dynamic'),\n lazy='dynamic')\n\n```", "```py\ndef unfollow(self, user):\n \"\"\"\n Unfollow the given user.\n\n Return `False` if the user was not already following the user.\n Otherwise, remove the user from the followed list and return\n the current object so that it may then be committed to the \n session.\n \"\"\"\n\n if not self.is_following(user):\n return False\n\n self.followed.remove(user)\n return self\n\ndef follow(self, user):\n \"\"\"\n Follow the given user.\n Return `False` if the user was already following the user.\n \"\"\"\n\n if self.is_following(user):\n return False\n\n self.followed.append(user)\n return self\n\ndef is_following(self, user):\n \"\"\"\n Returns boolean `True` if the current user is following the\n given `user`, and `False` otherwise.\n \"\"\"\n followed = self.followed.filter(followers.c.user_id == user.id)\n return followed.count() > 0\n\n```", "```py\nfrom application import db\nimport datetime\n\n__all__ = ['Post']\n\nclass Post(db.Model):\n\n # The unique primary key for each post created.\n id = db.Column(db.Integer, primary_key=True)\n # The free-form text-based content of each post.\n content = db.Column(db.Text())\n\n #  The date/time that the post was created on.\n created_on = db.Column(db.DateTime(),\n default=datetime.datetime.utcnow, index=True)\n\n # The user ID that created this post.\n user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))\n\n def __repr__(self):\n return '<Post %r>' % self.body\n\n```", "```py\ndef newsfeed(self):\n \"\"\"\n Return all posts from users followed by the current user,\n in descending chronological order.\n\n \"\"\"\n\n join_condition = followers.c.user_id == Post.user_id\n filter_condition = followers.c.follower_id == self.id\n ordering = Post.created_on.desc()\n\n return Post.query.join(followers,\n (join_condition)).filter(\n filter_condition).order_by(ordering)\n\n```", "```py\nSQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/test_app.db'\nDEBUG = True\nTESTING = True\n\n```", "```py\nimport pytest\nimport os\nfrom application import create_app, db as database\n\nDB_LOCATION = '/tmp/test_app.db'\n\n@pytest.fixture(scope='session')\ndef app():\n app = create_app(config='test_settings')\n return app\n\n@pytest.fixture(scope='session')\ndef db(app, request):\n \"\"\"Session-wide test database.\"\"\"\n if os.path.exists(DB_LOCATION):\n os.unlink(DB_LOCATION)\n\n database.app = app\n database.create_all()\n\n def teardown():\n database.drop_all()\n os.unlink(DB_LOCATION)\n request.addfinalizer(teardown)\n return database\n\n@pytest.fixture(scope='function')\ndef session(db, request):\n\n session = db.create_scoped_session()\n db.session = session\n\n def teardown():\n session.remove()\n\n request.addfinalizer(teardown)\n return session\n\n```", "```py\nfrom application.users import models\n\ndef test_create_user_instance(session):\n \"\"\"Create and save a user instance.\"\"\"\n\n email = 'test@example.com'\n username = 'test_user'\n password = 'foobarbaz'\n\n user = models.User(email, username, password)\n session.add(user)\n session.commit()\n\n # We clear out the database after every run of the test suite\n # but the order of tests may affect which ID is assigned.\n # Let's not depend on magic numbers if we can avoid it.\n assert user.id is not None\n\n assert user.followed.count() == 0\n assert user.newsfeed().count() == 0\n\n```", "```py\ndef test_user_relationships(session):\n \"\"\"User following relationships.\"\"\"\n\n user_1 = models.User(\n email='test1@example.com', username='test1',\n password='foobarbaz')\n user_2 = models.User(\n email='test2@example.com', username='test2',\n password='bingbarboo')\n\n session.add(user_1)\n session.add(user_2)\n\n session.commit()\n\n assert user_1.followed.count() == 0\n assert user_2.followed.count() == 0\n\n user_1.follow(user_2)\n\n assert user_1.is_following(user_2) is True\n assert user_2.is_following(user_1) is False\n assert user_1.followed.count() == 1\n\n user_1.unfollow(user_2)\n\n assert user_1.is_following(user_2) is False\n assert user_1.followed.count() == 0\n\n```", "```py\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\nfrom blinker import Namespace\n\n# Initialize the db extension, but without configuring\n# it with an application instance.\ndb = SQLAlchemy()\nflask_bcrypt = Bcrypt()\n\nsocializer_signals = Namespace()\nuser_followed = socializer_signals.signal('user-followed')\n\n# \u2026\n\n```", "```py\ndef follow(self, user):\n \"\"\"\n Follow the given user.\n\n Return `False` if the user was already following the user.\n \"\"\"\n\n if self.is_following(user):\n return False\n self.followed.append(user)\n\n # Publish the signal event using the current model (self) as sender.\n user_followed.send(self)\n\n return self\n\n```", "```pyfrom the application import `user_followed`` import line at the top of the `application/users/models.py` module.\n\nOnce we have an event that is published, a subscriber may be connected. Let's implement the signal handlers in `application/signal_handlers.py`:\n\n```", "```py\n\nFinally, we will need to ensure that our signal handlers are registered by importing the functions to the `application/__init__.py` module:\n\n```", "```py\n\nAfter this is added, every time a user follows another user, we will have a debug message printed to the configured log output. Implementing the functionality to actually send an e-mail to a user is left as an exercise for the reader; a good starting point would be to use the `Flask-Mail` extension.\n\n# Graceful handling of exceptions\n\nNo matter how hard we try, sometimes the code that we use and write will raise an exception.\n\nUsually, these exceptions are thrown in, well, exceptional circumstances, but that does not detract from the fact that we should understand which parts of our application may raise an exception and whether or not we want to handle the exception at the point of invocation or simply let it bubble up the call stack to another frame.\n\nFor our current application, there are several types of exceptions that we would like to handle in a graceful manner rather than let it crash the entire Python process and bring everything to an ugly, screeching halt.\n\nIn the previous chapter, we glossed over some of the necessary exception handling that needs to exist in most Flask and SQLAlchemy-based applications (or nearly any other database abstraction, for that matter), but the importance of handling these exceptions when they do arise cannot be understated. With this in mind, let's create some of the views, forms, and templates that will let us sign up as new users to our application and see a few examples of where and how to handle exceptions when they do arise.\n\nFirst, let's create our basic user view handlers in `application/users/views.py`:\n\n```", "```py\n\nYou'll notice that much of the login and logout functionality is similar to what we created in the previous chapter using the Flask-Login extension. So, we'll simply include these functionalities and defined routes without comment (in addition to the related Jinja templates) and focus on the new signup route that encapsulates the logic necessary to create a new user. This view utilizes the new `application/users/templates/users/signup.html` view, which simply includes the relevant form controls that allow a user to input their desired username, email address, and password:\n\n```", "```py\n\nOnce we have the preceding template in place, we will update our application factory to bind the user views to the application object. We will also initialize the Flask-Login extension as we did in the previous chapter:\n\n```", "```py\n\nDon't forget to add a `SECRET_KEY` configuration value to our `application/settings.py` module:\n\n```", "```py\n\nNow, we should be able to run the application and visit `http://localhost:5000/users/signup`, where we will be presented with a series of form inputs to create a new user account. On the successful creation of a new user, we will be automatically authenticated using the `login_user()` method of the Flask-Login extension.\n\nWhat we have not accounted for, however, are the situations where the creation of a user fails due to a mismatch with what our SQLAlchemy model and database expect. This may happen for a variety of reasons:\n\n*   An existing user has already claimed the submitted value for e-mail or username, both of which have been marked as unique in our user model\n*   A field requires additional validation criteria specified by the database, which are not met\n*   The database is unavailable (for example, due to network partition)\n\nIn order to ensure that these events are handled in the most graceful manner possible, we must encapsulate the portions of the code that may raise the relevant exceptions that signal one of these conditions. Thus, in our `application/users/views.py` module in the signup route, we will modify the portion of the code where we will persist the user to the database:\n\n```", "```py\n\nAdditionally, we will wrap `User.query.filter_by(username=form.username.data).one()` in the login route in the same module with a try/except block, to ensure that we handle the case where the username submitted in the login form does not exist at all in the database:\n\n```", "```py\n\n# Functional testing\n\nNow that we created a few routes and templates to handle user signup and login, let's utilize some of the `py.test` knowledge that we gained earlier in the chapter in order to write some post facto integration tests to ensure that our views are behaving as we expect. First, let's create a new test module in `application/tests/test_user_views.py` and write our first test that uses the client fixture so as to simulate a request to the application via the built-in Werkzeug test client. This will ensure that a proper request context has been constructed so that the context bound objects (for example, `url_for`, `g`) are available, as follows:\n\n```", "```py\n\nThe preceding test first makes a request to the `/users/signup` route and then asserts that the HTTP response code for this route is `200` (the default value for any successful return `render_template()` function). Then it asserts that the **Sign up!** button text appears in the returned HTML, which is a relatively safe guarantee that the page in question was rendered without any major errors.\n\nNext, let's add a test for a successful user signup, as follows:\n\n```", "```py\n\nIf we were to run the test suite immediately, it would fail. This is due to a somewhat subtle effect introduced by Flask-WTF, which expects a CSRF token to be provided for any submitted form data. The following are the two ways in which we can fix this:\n\n*   We can manually generate a CSRF token in the simulated POST data dictionary; the `WTForms` library provides the functionality to implement this\n*   We can set the `WTF_CSRF_ENABLED` configuration Boolean in the `test_settings.py` module to `False`, so that all the form validations that occur in the test suite will not require a CSRF token in order to be considered valid\n\nThe advantage of the first option is that the data sent across the request/response cycle will closely mirror what would happen in a production scenario, with the downside being that we are then responsible for generating (or programmatically abstracting) the required CSRF tokens for every single form that we want to test. The second option allows us to simply stop caring about the CSRF tokens completely while we are in the test suite, which is a downside as well. For the purpose of this chapter, we will use the method outlined in the second option.\n\nIn the preceding tests, we will first create a dictionary of our simulated form data that we would like to POST to our signup endpoint and then pass this data to the `client.post('/users/signup')` method. After the successful signup of a new user, we should expect to be redirected to a different page (we could also check the existence and value of the *Location* header in the response), in addition to the creation of a session ID by Flask-Login that will handle our user sessions. Moreover, a successful signup attempt for our current application means that we should have no flash messages that are stored for display and that a new user record with the provided data should be available and populated with the data that was supplied in the POST.\n\nWhile most developers are very keen on testing the success path of a request, it's equally, if not more, important to test the most common failure paths. To this end, let's add the following few tests for the most typical failure scenarios, the first of which would be the use of an invalid username:\n\n```", "```py\n\n### Note\n\nRemember, we defined our form validation rules for user signup in the `application.users.views.CreateUserForm` class; usernames are required to be between 3 and 40 characters long.\n\n```", "```py\n\n### Note\n\nIn the preceding test, we used an often overlooked convenience function of `py.test` (and other testing libraries), which is the `raises(exc)` context manager. This allows us to wrap a function call where we expect an exception to be raised and will itself cause a failure in the test suite if the expected exception type (or derived type) is not raised.\n\n# Your newsfeed\n\nWhile we have built up most of the supporting architecture to provide the functionality for our Socializer application, we are still missing one of the more fundamental pieces of the puzzle: being able to view the posts of the people you follow in a chronological order.\n\nTo make the display of information about the owner of a post a bit simpler, let's add a relationship definition to our `Post` model:\n\n```", "```py\n\nThis will allow us to use `post.user` to access any of the user information that is associated with a given post, which is going to be quite useful in any view that displays a single post or a list of posts.\n\nLet's add a route for this in `application/users/views.py`:\n\n```", "```py\n\nNote that the preceding snippet uses the `current_user` proxy (which you should import to the module) that is provided by the Flask-Login extension. As the Flask-Login extension stores the user object of the authenticated user in the proxy, we can call methods and attributes on it just as we would on a normal `user` object.\n\nAs the previous feed endpoint is up and running, we'll need the supporting template in `application/users/templates/users/feed.html` so that we can actually render a response:\n\n```", "```py\n\nThe last bit that we need is the view handler to add a new post. As we haven't created the `application/posts/views.py` module, let's do that. We'll need a `Flask-WTForm` class to handle/validate the new posts and a route handler to send and process the required fields, all hooked up to a new blueprint:\n\n```", "```py\n\nThe corresponding `application/posts/templates/posts/add.html` file is, as expected, relatively simple and reminiscent of the view template used in the previous chapter. Here it is:\n\n```", "```py\n\nFinally, we will need to make the application aware of this newly created posts blueprint by binding it to our application object in our application factory, in `application/__init__.py`:\n\n```"]