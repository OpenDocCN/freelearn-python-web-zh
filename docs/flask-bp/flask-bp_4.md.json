["```\n$ mkdir -p ~/src/socializer && cd ~/src/socializer\n$ mkvirtualenv socializer\n$ pip install flask flask-sqlalchemy flask-bcrypt flask-login flask-wtf blinker pytest-flask\n\n```", "```\n├── application\n│   ├── __init__.py\n│   └── users\n│       ├── __init__.py\n│       ├── models.py\n│       └── views.py\n└── run.py\n└── database.py\n\n```", "```\nfrom flask import Flask\n\ndef create_app(config=None):\n app = Flask(__name__)\n\n if config is not None:\n app.config.from_object(config)\n\n return app\n\n```", "```\nfrom flask import current_app as app\n\n```", "```\nfrom application import create_app\n\napp = create_app()\napp.run(debug=True)\n\n```", "```\n$ python run.py\n\n```", "```\n$ python –m run\n\n```", "```\nfrom myapp import create_app\nimport unittest\n\nclass AppTestCase(unittest.TestCase):\n\n def setUp(self):\n app = create_app()  # Could also pass custom settings.\n app.config['TESTING'] = True\n self.app = app\n\n # Whatever DB initialization is required\n\n def tearDown(self):\n # If anything needs to be cleaned up after a test.\n Pass\n\n def test_app_configuration(self):\n self.assertTrue(self.app.config['TESTING'])\n # Other relevant assertions\n\nif __name__ == '__main__':\n unittest.main()\n\n```", "```\nimport pytest\nfrom application import create_app\n\n@pytest.fixture\ndef app():\n app = create_app()\n return app\n\n```", "```\nimport flask\n\ndef test_app(app):\n assert isinstance(app, flask.Flask)\n\n```", "```\n$ py.test\n=============== test session starts ================\nplatform darwin -- Python 2.7.8 -- py-1.4.26 -- pytest-2.7.0\nrootdir: /path/to/socializer, inifile:\nplugins: flask\ncollected 1 items\n\ntests/test_application.py .\n\n============= 1 passed in 0.02 seconds =============\n\n```", "```\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\n\n# Initialize the db extension, but without configuring\n# it with an application instance.\ndb = SQLAlchemy()\n\n# The same for the Bcrypt extension\nflask_bcrypt = Bcrypt()\n\ndef create_app(config=None):\n app = Flask(__name__)\n\n if config is not None:\n app.config.from_object(config)\n\n # Initialize any extensions and bind blueprints to the\n # application instance here.\n db.init_app(app)\n flask_bcrypt.init_app(app)\n\n return app\n\n```", "```\nimport datetime\nfrom application import db, flask_bcrypt\nfrom sqlalchemy.ext.hybrid import hybrid_property\n\n__all__ = ['followers', 'User']\n\n# We use the explicit SQLAlchemy mappers for declaring the\n# followers table, since it does not require any of the features\n# that the declarative base model brings to the table.\n#\n# The `follower_id` is the entry that represents a user who\n# *follows* a `user_id`.\nfollowers = db.Table(\n 'followers',\n db.Column('follower_id', db.Integer, db.ForeignKey('user.id'),\n primary_key=True),\n db.Column('user_id', db.Integer, db.ForeignKey('user.id'),\n primary_key=True))\n\nclass User(db.Model):\n\n # The primary key for each user record.\n id = db.Column(db.Integer, primary_key=True)\n\n # The unique email for each user record.\n email = db.Column(db.String(255), unique=True)\n\n # The unique username for each record.\n username = db.Column(db.String(40), unique=True)\n\n # The hashed password for the user\n _password = db.Column('password', db.String(60))\n #  The date/time that the user account was created on.\n created_on = db.Column(db.DateTime,\n default=datetime.datetime.utcnow)\n\n followed = db.relationship('User',\n secondary=followers,\n primaryjoin=(id==followers.c.follower_id ),\n secondaryjoin=(id==followers.c.user_id),\n backref=db.backref('followers', lazy='dynamic'),\n lazy='dynamic')\n\n @hybrid_property\n def password(self):\n \"\"\"The bcrypt'ed password of the given user.\"\"\"\n\n return self._password\n\n @password.setter\n def password(self, password):\n \"\"\"Bcrypt the password on assignment.\"\"\"\n\n self._password = flask_bcrypt.generate_password_hash(\n password)\n\n def __repr__(self):\n return '<User %r>' % self.username\n\n def is_authenticated(self):\n \"\"\"All our registered users are authenticated.\"\"\"\n return True\n\n def is_active(self):\n \"\"\"All our users are active.\"\"\"\n return True\n\n def is_anonymous(self):\n \"\"\"We don't have anonymous users; always False\"\"\"\n return False\n def get_id(self):\n \"\"\"Get the user ID.\"\"\"\n return unicode(self.id)\n\n```", "```\n followed = db.relationship('User',\n secondary=followers,\n primaryjoin=(id==followers.c.follower_id ),\n secondaryjoin=(id==followers.c.user_id),\n backref=db.backref('followers', lazy='dynamic'),\n lazy='dynamic')\n\n```", "```\ndef unfollow(self, user):\n \"\"\"\n Unfollow the given user.\n\n Return `False` if the user was not already following the user.\n Otherwise, remove the user from the followed list and return\n the current object so that it may then be committed to the \n session.\n \"\"\"\n\n if not self.is_following(user):\n return False\n\n self.followed.remove(user)\n return self\n\ndef follow(self, user):\n \"\"\"\n Follow the given user.\n Return `False` if the user was already following the user.\n \"\"\"\n\n if self.is_following(user):\n return False\n\n self.followed.append(user)\n return self\n\ndef is_following(self, user):\n \"\"\"\n Returns boolean `True` if the current user is following the\n given `user`, and `False` otherwise.\n \"\"\"\n followed = self.followed.filter(followers.c.user_id == user.id)\n return followed.count() > 0\n\n```", "```\nfrom application import db\nimport datetime\n\n__all__ = ['Post']\n\nclass Post(db.Model):\n\n # The unique primary key for each post created.\n id = db.Column(db.Integer, primary_key=True)\n # The free-form text-based content of each post.\n content = db.Column(db.Text())\n\n #  The date/time that the post was created on.\n created_on = db.Column(db.DateTime(),\n default=datetime.datetime.utcnow, index=True)\n\n # The user ID that created this post.\n user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))\n\n def __repr__(self):\n return '<Post %r>' % self.body\n\n```", "```\ndef newsfeed(self):\n \"\"\"\n Return all posts from users followed by the current user,\n in descending chronological order.\n\n \"\"\"\n\n join_condition = followers.c.user_id == Post.user_id\n filter_condition = followers.c.follower_id == self.id\n ordering = Post.created_on.desc()\n\n return Post.query.join(followers,\n (join_condition)).filter(\n filter_condition).order_by(ordering)\n\n```", "```\nSQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/test_app.db'\nDEBUG = True\nTESTING = True\n\n```", "```\nimport pytest\nimport os\nfrom application import create_app, db as database\n\nDB_LOCATION = '/tmp/test_app.db'\n\n@pytest.fixture(scope='session')\ndef app():\n app = create_app(config='test_settings')\n return app\n\n@pytest.fixture(scope='session')\ndef db(app, request):\n \"\"\"Session-wide test database.\"\"\"\n if os.path.exists(DB_LOCATION):\n os.unlink(DB_LOCATION)\n\n database.app = app\n database.create_all()\n\n def teardown():\n database.drop_all()\n os.unlink(DB_LOCATION)\n request.addfinalizer(teardown)\n return database\n\n@pytest.fixture(scope='function')\ndef session(db, request):\n\n session = db.create_scoped_session()\n db.session = session\n\n def teardown():\n session.remove()\n\n request.addfinalizer(teardown)\n return session\n\n```", "```\nfrom application.users import models\n\ndef test_create_user_instance(session):\n \"\"\"Create and save a user instance.\"\"\"\n\n email = 'test@example.com'\n username = 'test_user'\n password = 'foobarbaz'\n\n user = models.User(email, username, password)\n session.add(user)\n session.commit()\n\n # We clear out the database after every run of the test suite\n # but the order of tests may affect which ID is assigned.\n # Let's not depend on magic numbers if we can avoid it.\n assert user.id is not None\n\n assert user.followed.count() == 0\n assert user.newsfeed().count() == 0\n\n```", "```\ndef test_user_relationships(session):\n \"\"\"User following relationships.\"\"\"\n\n user_1 = models.User(\n email='test1@example.com', username='test1',\n password='foobarbaz')\n user_2 = models.User(\n email='test2@example.com', username='test2',\n password='bingbarboo')\n\n session.add(user_1)\n session.add(user_2)\n\n session.commit()\n\n assert user_1.followed.count() == 0\n assert user_2.followed.count() == 0\n\n user_1.follow(user_2)\n\n assert user_1.is_following(user_2) is True\n assert user_2.is_following(user_1) is False\n assert user_1.followed.count() == 1\n\n user_1.unfollow(user_2)\n\n assert user_1.is_following(user_2) is False\n assert user_1.followed.count() == 0\n\n```", "```\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\nfrom blinker import Namespace\n\n# Initialize the db extension, but without configuring\n# it with an application instance.\ndb = SQLAlchemy()\nflask_bcrypt = Bcrypt()\n\nsocializer_signals = Namespace()\nuser_followed = socializer_signals.signal('user-followed')\n\n# …\n\n```", "```\ndef follow(self, user):\n \"\"\"\n Follow the given user.\n\n Return `False` if the user was already following the user.\n \"\"\"\n\n if self.is_following(user):\n return False\n self.followed.append(user)\n\n # Publish the signal event using the current model (self) as sender.\n user_followed.send(self)\n\n return self\n\n```", "```\n\n__all__ = ['user_followed_email']\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\nlogger = logging.getLogger(__name__)\n\ndef user_followed_email(user, **kwargs):\n\nlogger.debug(\n\n\"向{user}发送电子邮件\".format(user=user.username))\n\nfrom application import user_followed\n\ndef connect_handlers():\n\nuser_followed.connect(user_followed_email)\n\n```", "```\n\nfrom flask import Flask\n\nfrom flask.ext.sqlalchemy import SQLAlchemy\n\nfrom flask.ext.bcrypt import Bcrypt\n\nfrom blinker import Namespace\n\n# 初始化 db 扩展，但不配置\n\n# 它与应用程序实例一起。\n\ndb = SQLAlchemy()\n\nflask_bcrypt = Bcrypt()\n\nsocializer_signals = Namespace()\n\nuser_followed = socializer_signals.signal('user-followed')\n\nfrom signal_handlers import connect_handlers\n\nconnect_handlers()\n\n# …\n\n# …\n\n```", "```\n\nfrom flask import Blueprint, render_template, url_for, redirect, flash, g\n\nfrom flask.ext.login import login_user, logout_user\n\nfrom flask.ext.wtf import Form\n\nfrom wtforms import StringField, PasswordField\n\nfrom wtforms.validators import DataRequired, Length\n\nfrom models import User\n\nfrom application import db, flask_bcrypt\n\nusers = Blueprint('users', __name__, template_folder='templates')\n\nclass Login\tForm(Form):\n\n\"\"\"\n\n表示基本的登录表单元素和验证器。\n\n\"\"\"\n\nusername = StringField('username',\n\nvalidators=[DataRequired()])\n\npassword = PasswordField('password',\n\nvalidators=[DataRequired(),Length(min=6)])\n\nclass CreateUserForm(Form):\n\n\"\"\"\n\n封装创建新用户所需的必要信息。\n\n\"\"\"\n\nusername = StringField('username', validators=[DataRequired(), Length(min=3, max=40)])\n\nemail = StringField('email', validators=[DataRequired(), Length(max=255)])\n\npassword = PasswordField('password', validators=[DataRequired(),\n\nLength(min=8)])\n\n@users.route('/signup', methods=['GET', 'POST'])\n\ndef signup():\n\n\"\"\"\n\n基本用户创建功能。\n\n\"\"\"\n\nform = CreateUserForm()\n\nif form.validate_on_submit():\n\nuser = User( username=form.username.data,\n\nemail=form.email.data,\n\npassword=form.password.data)\n\n# 将用户添加到数据库\n\ndb.session.add(user)\n\ndb.session.commit()\n\n# 一旦我们成功将用户持久化到数据库中，\n\n# 验证当前会话的用户\n\nlogin_user(user，remember=True)\n\n返回重定向到 url_for('users.index')\n\n返回 render_template('users/signup.html'，form=form)\n\n@users.route('/'，methods=['GET'])\n\ndef index():\n\n返回\"用户索引页！\"，200\n\n@users.route('/login'，methods=['GET'，'POST'])\n\ndef login():\n\n\"\"\"\n\n基本用户登录功能。\n\n\"\"\"\n\n如果 g 中有'user'属性并且 g.user.is_authenticated（）：\n\n返回重定向到 url_for('users.index')\n\nform = LoginForm()\n\n如果 form.validate_on_submit（）：\n\n# 我们在这里使用 one（）而不是 first（）\n\nuser = User.query.filter_by(username=form.username.data).one()\n\n如果用户不存在或者 flask_bcrypt.check_password_hash(user.password，form.password.data)：\n\nflash(\"不存在这样的用户。\")\n\n返回 render_template('users/login.html'，form=form)\n\nlogin_user(user，remember=True)\n\n返回重定向到 url_for('users.index')\n\n返回 render_template('users/login.html'，form=form)\n\n@users.route('/logout'，methods=['GET'])\n\ndef logout():\n\nlogout_user()\n\n返回重定向到 url_for('users.login')\n\n```", "```\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n\n<form action=\"{{ url_for('users.signup')}}\" method=\"post\">\n\n{{ form.hidden_tag() }}\n\n{{ form.id }}\n\n<div>{{ form.username.label }}: {{ form.username }}</div>\n\n{% if form.username.errors %}\n\n<ul class=\"errors\">{% for error in form.username.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n\n{% endif %}\n\n<div>{{ form.email.label }}: {{ form.email }}</div>\n\n{% if form.email.errors %}\n\n<ul class=\"errors\">{% for error in form.email.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n\n{% endif %}\n\n<div>{{ form.password.label }}: {{ form.password }}</div>\n\n{% if form.password.errors %}\n\n<ul class=\"errors\">{% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n\n{% endif %}\n\n<div><input type=\"submit\" value=\"注册！\"></div>\n\n</form>\n\n{% endblock %}\n\n```", "```\n\n来自 flask 的导入 Flask\n\n来自 flask.ext.sqlalchemy 的导入 SQLAlchemy\n\n来自 flask.ext.bcrypt 的导入 Bcrypt\n\n来自 blinker 的导入 Namespace\n\n来自 flask.ext.login 的导入 LoginManager\n\n# 初始化 db 扩展，但不配置\n\n# 它与应用程序实例一起。\n\ndb = SQLAlchemy()\n\nflask_bcrypt = Bcrypt()\n\nlogin_manager = LoginManager()\n\nsocializer_signals = Namespace()\n\nuser_followed = socializer_signals.signal('user-followed')\n\nfrom signal_handlers import *\n\ndef create_app(config=None):\n\napp = Flask(__name__)\n\n如果 config 不为 None：\n\napp.config.from_object(config)\n\n# 初始化任何扩展并将蓝图绑定到\n\n# 应用程序实例在这里。\n\ndb.init_app(app)\n\nflask_bcrypt.init_app(app)\n\nlogin_manager.init_app(app)\n\n来自应用程序用户视图的导入用户\n\napp.register_blueprint(users，url_prefix='/users')\n\n来自应用程序用户的导入模型作为 user_models\n\n@login_manager.user_loader\n\nde fload_user(user_id):\n\n返回 user_models.User.query.get(int(user_id))\n\n返回 app\n\n```", "```\n\nSQLALCHEMY_DATABASE_URI = 'sqlite:///socializer.db'\n\nSECRET_KEY = 'BpRvzXZ800[-t:=z1eZtx9t/，P*'\n\n```", "```\n\n# 放在其他导入的地方…\n\n从 sqlalchemy 导入 exc\n\n# …\n\n尝试：\n\ndb.session.add(user)\n\ndb.session.commit()\n\nexcept exc.IntegrityError as e:\n\n# 唯一列约束被违反\n\ncurrent_app.exception(\"用户唯一约束违反。\")\n\n返回 render_template('users/signup.html'，form=form)\n\nexcept exc.SQLAlchemyError:\n\ncurrent_app.exception(\"无法保存新用户！\")\n\nflash(\"创建此用户时出现问题！\")\n\n返回 render_template('users/signup.html'，form=form)\n\n```", "```\n\n尝试：\n\n# 我们在这里使用 one（）而不是 first（）\n\nuser = User.query.filter_by(\n\nusername=form.username.data).one()s\n\nexcept NoResultFound:\n\nflash(\"用户{username}不存在。\".format(\n\nusername=form.username.data））\n\n返回 render_template('users/login.html'，form=form)\n\n# …\n\n```", "```\n\ndef test_get_user_signup_page(client):\n\n\"\"\"确保注册页面可用。\"\"\"\n\nresponse = client.get('/users/signup')\n\nassert response.status_code == 200\n\nassert '注册！' in response.data\n\n```", "```\n\n来自 flask 的导入 session，get_flashed_messages\n\n来自应用程序用户模型的导入用户\n\n来自应用程序的导入 flask_bcrypt\n\ndef test_signup_new_user（client）：\n\n\"\"\"成功注册新用户。\"\"\"\n\n数据= {'用户名'：'test_username'，'电子邮件'：'test@example.com'，\n\n'password'：'my test password'}\n\n响应=客户端发布（'/用户/注册'，数据=数据）\n\n# 成功创建后我们重定向。\n\n断言 response.status_code == 302\n\n# 断言由于成功登录而创建了会话\n\n断言'_id'在会话中\n\n# 确保我们没有存储的闪存消息指示错误\n\n# 发生。\n\n断言 get_flashed_messages（）== []\n\nuser = User.query.filter_by（username = data['username']）。one（）\n\n断言用户电子邮件==数据['电子邮件']\n\n断言用户密码\n\n断言 flask_bcrypt.check_password_hash（\n\nuser.password，data['password']）\n\n```", "```\n\n导入 pytest\n\n导入 sqlalchemy\n\ndef test_signup_invalid_user（client）：\n\n\"\"\"尝试使用无效数据注册。\"\"\"\n\n数据= {'用户名'：'x'，'电子邮件'：'short@example.com'，\n\n'password'：'a great password'}\n\n响应=客户端发布（'/用户/注册'，数据=数据）\n\n# 有了表单错误，我们仍然向客户端返回 200\n\n# 浏览器并不总是最擅长处理正确的 4xx 响应代码。\n\n断言 response.status_code == 200\n\n断言'must be between 3 and 40 characters long.'在 response.data 中\n\n```", "```\n\ndef test_signup_invalid_user_missing_fields（client）：\n\n\"\"\"尝试使用缺少的电子邮件注册。\"\"\"\n\n数据= {'用户名'：'no_email'，'密码'：'a great password'}\n\nresponse = client.post（'/users/signup'，数据=数据）\n\n断言 response.status_code == 200\n\n断言'required'在 response.data 中\n\nwith pytest.raises（sqlalchemy.orm.exc.NoResultFound）：\n\nUser.query.filter_by（username = data['username']）。one（）\n\n数据= {'用户名': '无密码'，'电子邮件'：'test@example.com'}\n\n响应=客户端发布（'/用户/注册'，数据=数据）\n\n断言 response.status_code == 200\n\n断言'required'在 response.data 中\n\nwith pytest.raises（sqlalchemy.orm.exc.NoResultFound）：\n\nUser.query.filter_by（username = data['username']）。one（）\n\n```", "```\n\n类帖子（db.Model）：\n\n# …\n\nuser = db.relationship（'User'，\n\nbackref = db.backref（'posts'，lazy ='dynamic'）\n\n```", "```\n\n@users.route（'/feed'，methods = ['GET']）\n\n@login_required\n\ndef feed（）：\n\n\"\"\"\n\n列出经过身份验证的用户的所有帖子；最近的第一个。\n\n\"\"\"\n\n帖子= current_user.newsfeed（）\n\n返回 render_template（'users/feed.html'，posts=posts）\n\n```", "```\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n\n<div class=\"new-post\">\n\n<p><a href=\"{{url_for('posts.add')}}\">New Post</a></p>\n\n</div>\n\n{% for post in posts %}\n\n<div class=\"post\">\n\n<span class=\"author\">{{post.user.username}}</span>，发布于<span class=\"date\">{{post.created_on}}</span>\n\n<pre><code>{{post.content}}</code></pre>\n\n</div>\n\n{% endfor %}\n\n{% endblock %}\n\n```", "```\n\n从 flask 导入蓝图，render_template，url_for，重定向，闪存，current_app\n\n从 flask.ext.login 导入 login_required，current_user\n\n从 flask.ext.wtf 导入表单\n\n从 wtforms 导入字符串字段\n\n从 wtforms.widgets 导入 TextArea\n\n从 wtforms.validators 导入 DataRequired\n\n从 sqlalchemy 导入 exc\n\n从模型导入帖子\n\n从应用程序导入 db\n\n帖子= Blueprint（'posts'，__name__，template_folder ='templates'）\n\n类 CreatePostForm（Form）：\n\n\"\"\"用于创建新帖子的表单。\"\"\"\n\ncontent = StringField（'content'，widget = TextArea（），\n\nvalidators=[DataRequired（）]\n\n@posts.route（'/add'，methods = ['GET'，'POST']）\n\n@login_required\n\ndef add（）：\n\n\"\"\"添加新帖子。\"\"\"\n\nform = CreatePostForm（）\n\n如果 form.validate_on_submit（）：\n\nuser_id = current_user.id\n\npost = Post（user_id = user_id，content = form.content.data）\n\ndb.session.add（post）\n\n尝试：\n\ndb.session.commit（）\n\n除了 exc.SQLAlchemyError：\n\ncurrent_app.exception（“无法保存新帖子！”）\n\n闪存（“创建您的帖子时出现问题！”）\n\n否则：\n\n返回 render_template（'posts/add.html'，form=form）\n\n返回重定向（url_for（'users.feed'））\n\n```", "```\n\n{% extends \"layout.html\" %}\n\n{% block content %}\n\n<form action=\"{{ url_for('posts.add')}}\" method=\"post\">\n\n{{ form.hidden_tag（）}}\n\n{{表单.id}}\n\n<div class=\"row\">\n\n<div>{{ form.content.label }}：{{ form.content }}</div>\n\n{% if form.content.errors %}\n\n<ul class=\"errors\">{% for error in form.content.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n\n{% endif %}\n\n</div>\n\n<div><input type=\"submit\" value=\"Post\"></div>\n\n</form>\n\n{% endblock %}\n\n```", "```\n\ndef create_app(config=None):\n\napp = Flask(__name__)\n\n# …\n\nfrom application.users.views import users\n\napp.register_blueprint(users, url_prefix='/users')\n\nfrom application.posts.views import posts\n\napp.register_blueprint(posts, url_prefix='/posts')\n\n# …\n\n```"]