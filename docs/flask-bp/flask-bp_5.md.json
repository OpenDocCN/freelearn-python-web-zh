["```py\n$ mkdir -p ~/src/shutterbug && cd ~/src/shutterbug\n$ mkvirtualenv shutterbug\n$ pip install flask flask-sqlalchemy pytest-flask flask-bcrypt\n\n```", "```py\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 resources\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 photos.py\n\u251c\u2500\u2500 conftest.py\n\u251c\u2500\u2500 database.py\n\u251c\u2500\u2500 run.py\n\u251c\u2500\u2500 settings.py\n\u2514\u2500\u2500 tests/\n```", "```py\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\n\n# Initialize the db extension, but without configuring\n# it with an application instance.\ndb = SQLAlchemy()\nflask_bcrypt = Bcrypt()\n\ndef create_app(config=None):\n    app = Flask(__name__)\n\n    if config is not None:\n        app.config.from_object(config)\n\n    db.init_app(app)\n    flask_bcrypt.init_app(app)\n\n    return app\n```", "```py\nfrom application import create_app\n\napp = create_app()\napp.run()\n```", "```py\n$ python run.py\n\n```", "```py\n$ pip install flask-restful\n\n```", "```py\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\nfrom flask.ext.restful import Api\n\n# \u2026\u2026\u2026\napi = Api()\n\ndef create_app(config=None):\n    app = Flask(__name__)\n\n    if config is not None:\n        app.config.from_object(config)\n\n    db.init_app(app)\n    flask_bcrypt.init_app(app)\n\n api.init_app(app)\n\n    return app\n```", "```py\nclass SinglePhoto(Resource):\n\n    def get(self, photo_id):\n        \"\"\"Handling of GET requests.\"\"\"\n        pass\n\n    def delete(self, photo_id):\n        \"\"\"Handling of DELETE requests.\"\"\"\n        pass\n\nclass ListPhoto(Resource):\n\n    def get(self):\n        \"\"\"Handling of GET requests.\"\"\"\n        pass\n\n    def post(self):\n        \"\"\"Handling of POST requests.\"\"\"\n        pass\n```", "```py\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.restful import Api\nfrom flask.ext.bcrypt import Bcrypt\n\n# Initialize the db extension, but without configuring\n# it with an application instance.\ndb = SQLAlchemy()\napi = Api()\nflask_bcrypt = Bcrypt()\n\ndef create_app(config=None):\n    app = Flask(__name__)\n\n    if config is not None:\n        app.config.from_object(config)\n\n    db.init_app(app)\n    flask_bcrypt.init_app(app)\n\n from .resources.photos import SinglePhoto, ListPhoto\n api.add_resource(ListPhoto, '/photos')\n api.add_resource(SinglePhoto, '/photos/<int:photo_id>')\n\n    api.init_app(app)\n\n    return app\n```", "```py\nIn [1]: from application import create_app\nIn [2]: app = create_app()\nIn [3]: app.url_map\nOut[3]:\nMap([<Rule '/photos' (HEAD, POST, OPTIONS, GET) -> listphoto>,\n <Rule '/photos/<photo_id>' (HEAD, DELETE, OPTIONS, GET) -> singlephoto>,\n <Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>])\n\n```", "```py\n app = Flask(__name__, static_folder=None)\n\n```", "```py\nfrom flask.ext.restful import Resource\n\nclass SingleUser(Resource):\n\n    def get(self, user_id):\n        \"\"\"Handling of GET requests.\"\"\"\n        pass\n\nclass CreateUser(Resource):\n\n    def post(self):\n        \"\"\"Handling of POST requests.\"\"\"\n        pass\n```", "```py\ndef create_app(config=None):\n\n    # \u2026\n\n    from .resources.photos import SinglePhoto, ListPhoto\n    from .resources.users import SingleUser, CreateUser\n\n    api.add_resource(ListPhoto, '/photos')\n    api.add_resource(SinglePhoto, '/photos/<int:photo_id>')\n    api.add_resource(SingleUser, '/users/<int:user_id>')\n    api.add_resource(CreateUser, '/users')\n\n    api.init_app(app)\n    return app\n```", "```py\nfrom application import db, flask_bcrypt\nfrom sqlalchemy.ext.hybrid import hybrid_property\n\nimport datetime\n\nclass User(db.Model):\n    \"\"\"SQLAlchemy User model.\"\"\"\n\n    # The primary key for each user record.\n    id = db.Column(db.Integer, primary_key=True)\n\n    # The unique email for each user record.\n    email = db.Column(db.String(255), unique=True, nullable=False)\n\n    # The unique username for each record.\n    username = db.Column(db.String(40), unique=True, nullable=False)\n\n # The bcrypt'ed user password\n _password = db.Column('password', db.String(60), nullable=False)\n\n    #  The date/time that the user account was created on.\n    created_on = db.Column(db.DateTime,\n       default=datetime.datetime.utcnow)\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n\n @hybrid_property\n def password(self):\n \"\"\"The bcrypt'ed password of the given user.\"\"\"\n\n return self._password\n\n @password.setter\n def password(self, password):\n \"\"\"Bcrypt the password on assignment.\"\"\"\n\n        self._password = flask_bcrypt.generate_password_hash(password)\n```", "```py\nclass Photo(db.Model):\n    \"\"\"SQLAlchemy Photo model.\"\"\"\n\n    # The unique primary key for each photo created.\n    id = db.Column(db.Integer, primary_key=True)\n\n    # The free-form text-based comment of each photo.\n    comment = db.Column(db.Text())\n\n    # Path to photo on local disk\n    path = db.Column(db.String(255), nullable=False)\n\n    #  The date/time that the photo was created on.\n    created_on = db.Column(db.DateTime(),\n        default=datetime.datetime.utcnow, index=True)\n\n    # The user ID that created this photo.\n    user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))\n\n    # The attribute reference for accessing photos posted by this user.\n    user = db.relationship('User', backref=db.backref('photos',\n        lazy='dynamic'))\n\n    def __repr__(self):\n        return '<Photo %r>' % self.comment\n```", "```py\n$ pip install flask-httpauth\n\n```", "```py\nfrom flask import Flask\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.restful import Api\nfrom flask.ext.bcrypt import Bcrypt\nfrom flask.ext.httpauth import HTTPBasicAuth\n\n# \u2026\n\napi = Api()\nflask_bcrypt = Bcrypt()\nauth = HTTPBasicAuth()\n\ndef create_app(config=None):\n    # \u2026\n\n import authentication\n\n    api.add_resource(ListPhoto, '/photos')\n    api.add_resource(SinglePhoto, '/photos/<int:photo_id>')\n\n    # \u2026\n```", "```py\nimport sqlalchemy\nfrom . import auth, flask_bcrypt\nfrom .models import User\nfrom flask import g\n\n@auth.verify_password\ndef verify_password(username, password):\n    \"\"\"Verify a username/hashed password tuple.\"\"\"\n\n    try:\n        user = User.query.filter_by(username=username).one()\n    except sqlalchemy.orm.exc.NoResultFound:\n        # We found no username that matched\n        return False\n\n    # Perform password hash comparison in time-constant manner.\n    verified = flask_bcrypt.check_password_hash(user.password,\n        password)\n\n if verified is True:\n g.current_user = user\n\n    return verified\n```", "```py\nfrom flask.ext.restful import Resource\nfrom application import auth\n\nclass SingleUser(Resource):\n\n method_decorators = [auth.login_required]\n\n    def get(self, user_id):\n        \"\"\"Handling of GET requests.\"\"\"\n        pass\n\n    # \u2026\n```", "```py\nfrom flask.ext.restful import abort\n\n# \u2026\n\ndef get(self, user_id):\n    \"\"\"Handling of GET requests.\"\"\"\n\n    if g.current_user.id != user_id:\n        # A user may only access their own user data.\n        abort(403, message=\"You have insufficient permissions\"\n            \" to access this resource.\")\n\n    # We could simply use the `current_user`,\n    # but the SQLAlchemy identity map makes this a virtual\n    # no-op and alos allows for future expansion\n    # when users may access information of other users\n    try:\n        user = User.query.filter(User.id == user_id).one()\n    except sqlalchemy.orm.exc.NoResultFound:\n        abort(404, message=\"No such user exists!\")\n\n    data = dict(\n        id=user.id,\n        username=user.username,\n        email=user.email,\n        created_on=user.created_on)\n\n    return data, 200\n```", "```py\nif g.current_user.id != user_id:\n        # A user may only access their own user data.\n        abort(403, message=\"You have insufficient permissions\"\n            \" to access this resource.\")\n```", "```py\ntry:\n    user = User.query.filter(User.id == user_id).one()\nexcept sqlalchemy.orm.exc.NoResultFound:\n    abort(404, message=\"No such user exists!\")\n```", "```py\ndata = dict(id=user.id, username=user.username, email=user.email,\n            created_on=user.created_on)\n\n    return data, 200\n```", "```py\nfrom flask import Flask, json, make_response\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.restful import Api\nfrom flask.ext.bcrypt import Bcrypt\nfrom flask.ext.httpauth import HTTPBasicAuth\n\n# \u2026\n\ndb = SQLAlchemy()\n# \u2026\n\n@api.representation('application/json')\ndef output_json(data, code, headers=None):\n    resp = make_response(json.dumps(data), code)\n    resp.headers.extend(headers or {})\n    return resp\n```", "```py\nclass CreateUser(Resource):\n\n    def post(self):\n        \"\"\"Create a new user.\"\"\"\n\n        data = request.json\n        user = User(**data)\n\n        db.session.add(user)\n\n        try:\n            db.session.commit()\n        except sqlalchemy.exc.IntegrityError:\n            abort(409, message=\"User already exists!\")\n\n        data = dict(id=user.id, username=user.username, email=user.email, created_on=user.created_on)\n\n        return data, 201, {'Location': url_for( 'singleuser', user_id=user.id, _external=True)}\n```", "```py\nfrom flask.ext.restful import Resource, abort, reqparse, url_for\n\n# \u2026\n\nnew_user_parser = reqparse.RequestParser()\nnew_user_parser.add_argument('username', type=str, required=True)\nnew_user_parser.add_argument('email', type=str, required=True)\nnew_user_parser.add_argument('password', type=str, required=True)\n```", "```py\ndef post(self):\n    \"\"\"Handling of POST requests.\"\"\"\n\n    data = new_user_parser.parse_args(strict=True)\n    user = User(**data)\n\n    db.session.add(user)\n\n    # \u2026\n```", "```py\nimport pytest\nimport os\nfrom application import create_app, db as database\n\nDB_LOCATION = '/tmp/test_shutterbug.db'\n\n@pytest.fixture(scope='session')\ndef app():\n    app = create_app(config='test_settings')\n    return app\n\n@pytest.fixture(scope='function')\ndef db(app, request):\n    \"\"\"Session-wide test database.\"\"\"\n    if os.path.exists(DB_LOCATION):\n        os.unlink(DB_LOCATION)\n\n    database.app = app\n    database.create_all()\n\n    def teardown():\n        database.drop_all()\n        os.unlink(DB_LOCATION)\n\n    request.addfinalizer(teardown)\n    return database\n\n@pytest.fixture(scope='function')\ndef session(db, request):\n\n    session = db.create_scoped_session()\n    db.session = session\n\n    def teardown():\n        session.remove()\n\n    request.addfinalizer(teardown)\n    return session\n```", "```py\nSQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/test_shutterbug.db'\nSECRET_KEY = b\"\\x98\\x9e\\xbaP'D\\x03\\xf5\\x91u5G\\x1f\"\nDEBUG = True\nUPLOAD_FOLDER = '/tmp/'\nTESTING = True\n\n```", "```py\nfrom application.models import User\nfrom flask import json\nimport base64\n\ndef test_create_new_user(db, session, client):\n    \"\"\"Attempt to create a basic user.\"\"\"\n\n    data = {'username': 'you', 'email': 'you@example.com',\n            'password': 'foobar'}\n\n    response = client.post('/users', data=data)\n    assert response.status_code == 201\n    assert 'Location' in response.headers\n\n    user = User.query.filter(User.username == data['username']).one()\n\n    assert '/users/{}'.format(user.id) in response.headers['Location']\n```", "```py\ndef test_create_invalid_user(db, session, client):\n    \"\"\"Try to create a user with invalid/missing information.\"\"\"\n\n    data = {'email': 'you@example.com'}\n    response = client.post('/users', data=data)\n\n    assert response.status_code == 400\n    assert 'message' in response.json\n    assert 'username' in response.json['message']\n```", "```py\ndef test_get_single_user_authenticated(db, session, client):\n    \"\"\"Attempt to fetch a user.\"\"\"\n\n    data = {'username': 'authed', 'email': 'authed@example.com',\n            'password': 'foobar'}\n    user = User(**data)\n    session.add(user)\n    session.commit()\n\n    creds = base64.b64encode(\n        b'{0}:{1}'.format(\n            user.username, data['password'])).decode('utf-8')\n\n    response = client.get('/users/{}'.format(user.id),\n        headers={'Authorization': 'Basic ' + creds})\n\n    assert response.status_code == 200\n    assert json.loads(response.get_data())['id'] == user.id\n```", "```py\ndef test_get_single_user_unauthenticated(db, session, client):\n    data = {'username': 'authed', 'email': 'authed@example.com',\n            'password': 'foobar'}\n    user = User(**data)\n    session.add(user)\n    session.commit()\n\n    response = client.get('/users/{}'.format(user.id))\n    assert response.status_code == 401\n```", "```py\ndef test_get_single_user_unauthorized(db, session, client):\n\n    alice_data = {'username': 'alice', 'email': 'alice@example.com',\n            'password': 'foobar'}\n    bob_data = {'username': 'bob', 'email': 'bob@example.com',\n            'password': 'foobar'}\n    alice = User(**alice_data)\n    bob = User(**bob_data)\n\n    session.add(alice)\n    session.add(bob)\n\n    session.commit()\n\n    alice_creds = base64.b64encode(b'{0}:{1}'.format(\n        alice.username, alice_data['password'])).decode('utf-8')\n\n    bob_creds = base64.b64encode(b'{0}:{1}'.format(\n        bob.username, bob_data['password'])).decode('utf-8')\n\n    response = client.get('/users/{}'.format(alice.id),\n        headers={'Authorization': 'Basic ' + bob_creds})\n\n    assert response.status_code == 403\n\n    response = client.get('/users/{}'.format(bob.id),\n        headers={'Authorization': 'Basic ' + alice_creds})\n\n    assert response.status_code == 403\n```", "```py\nimport re\n\nversion_pattern = re.compile(r\"/v(?P<version>[0-9a-z\\-\\+\\.]+)\", re.IGNORECASE)\n\nclass VersionedAPIMiddleware(object):\n    \"\"\"\n\n    The line wrapping here is a bit off, but it's not critical.\n\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        path = environ.get('PATH_INFO', '')\n\n        match = version_pattern.match(path)\n\n        if match:\n            environ['API_VERSION'] = match.group(1)\n            environ['PATH_INFO'] = re.sub(version_pattern, '', path,\n                count=1)\n        else:\n            environ['API_VERSION'] = None\n\n        return self.app(environ, start_response)\n```", "```py\n# \u2026\n\nfrom .middlewares import VersionedAPIMiddleware\n\n# \u2026\ndef create_app(config=None):\n    app = Flask(__name__, static_folder=None)\n app.wsgi_app = VersionedAPIMiddleware(app.wsgi_app)\n\n    # \u2026\n\n    api.init_app(app)\n    return app\n```", "```py\nfrom flask import request\n# \u2026\n# \u2026\nif request.environ['API_VERSION'] > 2:\n    # Handle this differently\nelse:\n    # Handle it normally\n```", "```py\nfrom flask.ext.restful import Resource, reqparse\nfrom flask import current_app, request, g, url_for\nfrom application import auth, db, models\nimport uuid\nimport os\nimport werkzeug\n\nnew_photo_parser = reqparse.RequestParser()\nnew_photo_parser.add_argument('comment', type=str,\n    required=False)\nnew_photo_parser.add_argument('photo',\n    type=werkzeug.datastructures.FileStorage,\n    required=True, location='files')\n\nclass UploadPhoto(Resource):\n\n    method_decorators = [auth.login_required]\n\n    def post(self):\n        \"\"\"Adds a new photo via form-encoded POST data.\"\"\"\n\n        data = new_photo_parser.parse_args(strict=True)\n\n        # Save our file to the filesystem first\n        f = request.files['photo']\n\n        extension = os.path.splitext(f.filename)[1]\n        name = werkzeug.utils.secure_filename(\n            str(uuid.uuid4()) + extension)\n        path = os.path.join(\n            current_app.config['UPLOAD_FOLDER'], name)\n\n        f.save(path)\n\n        data['user_id'] = g.current_user.id\n        data['path'] = path\n\n        # Get rid of the binary data that was sent; we've already\n        # saved this to disk.\n        del data['photo']\n\n        # Add a new Photo entry to the database once we have\n        # successfully saved the file to the filesystem above.\n        photo = models.Photo(**data)\n        db.session.add(photo)\n        db.session.commit()\n\n        data = dict(id=photo.id,\n            path=photo.path, comment=photo.comment,\n            created_on=photo.created_on)\n\n        return data, 201, {'Location': url_for('singlephoto',\n            photo_id=photo.id, _external=True)}\n```", "```py\ndef create_app(config=None):\n    # \u2026\n\n from .resources.photos import (SinglePhoto, ListPhoto,\n UploadPhoto)\n # \u2026\n\n    api.add_resource(ListPhoto, '/photos')\n api.add_resource(UploadPhoto, '/photos')\n    api.add_resource(SinglePhoto, '/photos/<int:photo_id>')\n    api.add_resource(SingleUser, '/users/<int:user_id>')\n    api.add_resource(CreateUser, '/users')\n\n    # \u2026\n```", "```py\nimport io\nimport base64\nfrom application.models import User, Photo\n\ndef test_unauthenticated_form_upload_of_simulated_file(session, client):\n    \"\"\"Ensure that we can't upload a file via un-authed form POST.\"\"\"\n\n    data = dict(\n        file=(io.BytesIO(b'A test file.'), 'test.png'))\n\n    response = client.post('/photos', data=data)\n    assert response.status_code == 401\n```", "```py\ndef test_authenticated_form_upload_of_simulated_file(session, client):\n    \"\"\"Upload photo via POST data with authenticated user.\"\"\"\n\n    password = 'foobar'\n    user = User(username='you', email='you@example.com',\n        password=password)\n\n    session.add(user)\n\n    data = dict(\n        photo=(io.BytesIO(b'A test file.'), 'test.png'))\n\n    creds = base64.b64encode(\n        b'{0}:{1}'.format(user.username, password)).decode('utf-8')\n\n    response = client.post('/photos', data=data,\n        headers={'Authorization': 'Basic ' + creds})\n\n    assert response.status_code == 201\n    assert 'Location' in response.headers\n\n    photos = Photo.query.all()\n    assert len(photos) == 1\n\n    assert ('/photos/{}'.format(photos[0].id) in\n        response.headers['Location'])\n```", "```py\ndef test_upload_photo_with_comment(session, client):\n    \"\"\"Adds a photo with a comment.\"\"\"\n\n    password = 'foobar'\n    user = User(username='you', email='you@example.com',\n    password=password)\n\n    session.add(user)\n\n    data = dict(\n        photo=(io.BytesIO(b'A photo with a comment.'),\n        'new_photo.png'),\n        comment='What an inspiring photo!')\n\n    creds = base64.b64encode(\n        b'{0}:{1}'.format(\n            user.username, password)).decode('utf-8')\n\n    response = client.post('/photos', data=data,\n        headers={'Authorization': 'Basic ' + creds})\n\n    assert response.status_code == 201\n    assert 'Location' in response.headers\n\n    photos = Photo.query.all()\n    assert len(photos) == 1\n\n    photo = photos[0]\n    assert photo.comment == data['comment']\n```", "```py\nfrom flask.ext.restful import Resource, reqparse, fields, marshal\nphotos_parser = reqparse.RequestParser()\nphotos_parser.add_argument('page', type=int, required=False,\n        default=1, location='args')\nphotos_parser.add_argument('limit', type=int, required=False,\n        default=10, location='args')\n\nphoto_fields = {\n    'path': fields.String,\n    'comment': fields.String,\n    'created_on': fields.DateTime(dt_format='rfc822'),\n}\n\nclass ListPhoto(Resource):\n\n    method_decorators = [auth.login_required]\n\n    def get(self):\n        \"\"\"Get reverse chronological list of photos for the\n        currently authenticated user.\"\"\"\n\n        data = photos_parser.parse_args(strict=True)\n        offset = (data['page'] - 1) * data['limit']\n        photos = g.current_user.photos.order_by(\n            models.Photo.created_on.desc()).limit(\n            data['limit']).offset(offset)\n\n        return marshal(list(photos), photo_fields), 200\n```"]