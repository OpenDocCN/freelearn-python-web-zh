["```py\nurl (r'^create_project$', CreateView.as_view(model=Project, template_name=\"en/public/create_project.html\", success_url = 'index'), name=\"create_project\"),\n```", "```py\nfrom django.views.generic import CreateView\nfrom TasksManager.models import Project\n```", "```py\nfrom TasksManager.models import Project, Task\nurl (r'^create_task$', CreateView.as_view(model=Task, template_name=\"en/public/create_task.html\", success_url = 'index'), name=\"create_task\"),\n```", "```py\n<a href=\"{% url \"create_task\" %}\">Create task</a>\n```", "```py\nfrom TasksManager.models import Project\nfrom django.views.generic.list import ListView\n```", "```py\nurl (r'^project_list$', ListView.as_view(model=Project, template_name=\"en/public/project_list.html\"), name=\"project_list\"),\n```", "```py\n<table>\n<tr>\n  <th>Title</th>\n  <th>Description</th>\n  <th>Client name</th>\n</tr>\n{% for project in object_list %}\n  <tr>\n    <td>{{ project.title }}</td>\n    <td>{{ project.description }}</td>\n    <td>{{ project.client_name }}</td>\n  </tr>\n{% endfor %}\n</table>\n```", "```py\nfrom django.views.generic.list import ListView \n# In this line, we import the ListView class\nfrom TasksManager.models import Project\n\nclass Project_list(ListView): \n# In this line, we create a class that extends the ListView class.\n  model=Project\n  template_name = 'en/public/project_list.html' \n# In this line, we define the template_name the same manner as in the urls.py file.\n  paginate_by = 5 \nIn this line, we define the number of visible projects on a single page.\n  def get_queryset(self): \nIn this line, we override the get_queryset() method to return our queryset.\n    queryset=Project.objects.all().order_by(\"title\")\n    return queryset\n```", "```py\nListView.py file:\n```", "```py\nurl (r'^project_list$', Project_list.as_view(), name=\"project_list\"),\n```", "```py\n{% if is_paginated %}\n  <div class=\"pagination\">\n    <span>\n    {% if page_obj.has_previous %}\n      <a href=\"{% url \"project_list\" %}?page={{ page_obj.previous_page_number }}\">Previous</a>\n    {% endif %}\n    <span style=\"margin-left:15px;margin-right:15px;\">\n      Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}.\n    </span>\n    {% if page_obj.has_next %}\n      <a href=\"{% url \"project_list\" %}?page={{ page_obj.next_page_number }}\">Next</a>\n    {% endif %}\n    </span>\n  </div>\n{% endif %}\n```", "```py\nurl (r'^developer_list$', ListView.as_view(model=Developer, template_name=\"en/public/developer_list.html\"), name=\"developer_list\"),\n```", "```py\n<table>\n  <tr>\n    <td>Name</td>\n    <td>Login</td>\n    <td>Supervisor</td>\n  </tr>\n  {% for dev in object_list %}\n    <tr>\n      <td><a href=\"\">{{ dev.name }}</a></td>\n      <td>{{ dev.login }}</td>\n      <td>{{ dev.supervisor }}</td>\n    </tr>\n  {% endfor %}\n</table>\n```", "```py\nfrom django.views.generic import DetailView\nfrom TasksManager.models import Task\nurl (r'^task_detail_(?P<pk>\\d+)$', DetailView.as_view(model=Task, template_name=\"en/public/task_detail.html\"), name=\"task_detail\"),\n```", "```py\n<h4>\n  {{ object.title }}\n</h4>\n<table>\n  <tr>\n    <td>Project : {{ object.project }}</td>\n    <td>Developer : {{ object.app_user }}</td>\n  </tr>\n  <tr>\n    <td>Importence : {{ object.importence }}</td>\n    <td>Time elapsed : {{ object.time_elapsed }}</td>\n  </tr>\n</table>\n<p>\n  {{ object.description }}\n</p>\n```", "```py\n<a href=\"{% url \"task_detail\" \"1\" %}\">Detail first view</a><br />\n```", "```py\nfrom django.views.generic import DetailView\nfrom TasksManager.models import Developer, Task\n\nclass Developer_detail(DetailView): \n  model=Developer\n  template_name = 'en/public/developer_detail.html'\n  def get_context_data(self, **kwargs):\n    # This overrides the get_context_data() method.\n    context = super(Developer_detail, self).get_context_data(**kwargs) \n    # This allows calling the method of the super class. Without this line we would not have the basic context.\n    tasks_dev = Task.objects.filter(developer = self.object) \n    # This allows us to retrieve the list of developer tasks. We use self.object, which is a Developer type object already defined by the DetailView class.\n    context['tasks_dev'] = tasks_dev \n    # In this line, we add the task list to the context.\n    return context\n```", "```py\nfrom TasksManager.views.cbv.DetailView import Developer_detail \nurl (r'^developer_detail_(?P<pk>\\d+)$', Developer_detail.as_view(), name=\"developer_detail\"),\n```", "```py\n<h4>\n  {{ object.name }}\n</h4>\n<span>Login : {{ object.login }}</span><br />\n<span>Email : {{ object.email }}</span>\n<h3>Tasks</h3>\n<table>\n  {% for task in tasks_dev %}\n  <tr>\n    <td>{{ task.title }}</td>\n    <td>{{ task.importence }}</td>\n    <td>{{ task.project }}</td>\n  </tr>\n  {% endfor %}\n</table>\n```", "```py\nfrom django.views.generic import UpdateView\nurl (r'^update_task_(?P<pk>\\d+)$', UpdateView.as_view(model=Task, template_name=\"en/public/update_task.html\", success_url=\"index\"), name=\"update_task\"),\n```", "```py\n<form method=\"post\" action=\"\">\n  {% csrf_token %} \n  <table>\n    {{ form.as_table }} \n  </table>\n  <p><input type=\"submit\" value=\"Update\" /></p>\n</form>\n```", "```py\nfrom django.views.generic import UpdateView\nfrom TasksManager.models import Task\nfrom django.forms import ModelForm\nfrom django.core.urlresolvers import reverse\n\nclass Form_task_time(ModelForm): \n# In this line, we create a form that extends the ModelForm. The UpdateView and CreateView CBV are based on a ModelForm system.\n  class Meta:\n    model = Task\n    fields = ['time_elapsed'] \n    # This is used to define the fields that appear in the form. Here there will be only one field.\n\nclass Task_update_time(UpdateView):\n  model = Task\n  template_name = 'en/public/update_task_developer.html'\nform_class = Form_task_time \n# In this line, we impose your CBV to use the ModelForm we created. When you do not define this line, Django automatically generates a ModelForm.\n  success_url = 'public_empty' \n  # This line sets the name of the URL that will be seen once the change has been completed.\n  def get_success_url(self): \n  # In this line, when you put the name of a URL in the success_url property, we have to override this method. The reverse() method returns the URL corresponding to a URL name.\n    return reverse(self.success_url)\n```", "```py\nfrom TasksManager.views.cbv.UpdateView import Task_update_time\nurl (r'^update_task_time_(?P<pk>\\d+)$', Task_update_time.as_view(), name = \"update_task_time\"),\n```", "```py\nfrom django.core.urlresolvers import reverse\nfrom django.views.generic import DeleteView\nfrom TasksManager.models import Task\n\nclass Task_delete(DeleteView):\n  model = Task\n  template_name = 'en/public/confirm_delete_task.html'\n  success_url = 'public_empty'\n  def get_success_url(self):\n    return reverse(self.success_url)\n```", "```py\nfrom TasksManager.views.cbv.DeleteView import Task_delete\nurl(r'task_delete_(?P<pk>\\d+)$', Task_delete.as_view(), name=\"task_delete\"),\n```", "```py\n<h3>Do you want to delete this object?</h3>\n<form method=\"post\" action=\"\">\n  {% csrf_token %} \n  <table>\n    {{ form.as_table }} \n  </table>\n  <p><input type=\"submit\" value=\"Delete\" /></p>\n</form>\n```", "```py\nclass Task(models.Model):\n  # fields\n  def __str__(self):\n    return self.title\n  class Meta:\n    verbose_name = \"task\"\n    verbose_name_plural = \"tasks\"\n```", "```py\nfrom django.views.generic import UpdateView\nfrom django.core.urlresolvers import reverse\n\nclass UpdateViewCustom(UpdateView):\n  template_name = 'en/cbv/UpdateViewCustom.html' \n  # In this line, we define the template that will be used for all the CBVs that extend the UpdateViewCustom class. This template_name field can still be changed if we need it.\n  url_name=\"\" \n  # This line is used to create the url_name property. This property will help us to define the name of the current URL. In this way, we can add the link in the action attribute of the form.\n  def get_success_url(self):\n  # In this line, we override the get_success_url() method by default, this method uses the name URLs.\n    return reverse(self.success_url)\n  def get_context_data(self, **kwargs): \n  # This line is the method we use to send data to the template.\n    context = super(UpdateViewCustom, self).get_context_data(**kwargs) \n    # In this line, we perform the super class method to send normal data from the CBV UpdateView.\n    model_name = self.model._meta.verbose_name.title() \n    # In this line, we get the verbose_name property of the defined model.\n    context['model_name'] = model_name \n    # In this line, we send the verbose_name property to the template.\n    context['url_name'] = self.url_name \\\n    # This line allows us to send the name of our URL to the template.\n    return context\n```", "```py\n{% extends \"base.html\" %}\n{% block title_html %}\n  Update a {{ model_name }} \n  <!-- In this line, we show the type of model we want to change here. -->\n{% endblock %}\n{% block h1 %}\n  Update a {{ model_name }} \n{% endblock %}\n{% block article_content %}\n  <form method=\"post\" action=\"{% url url_name object.id %}\"> <!-- line 2 -->\n  <!-- In this line, we use our url_name property to redirect the form to the current page. -->\n    {% csrf_token %} \n    <table>\n      {{ form.as_table }} \n    </table>\n    <p><input type=\"submit\" value=\"Update\" /></p>\n  </form>\n{% endblock %}\n```", "```py\nurl (r'^update_task_(?P<pk>\\d+)$', UpdateViewCustom.as_view(model=Task, url_name=\"update_task\", success_url=\"public_empty\"), name=\"update_task\"),\n```"]